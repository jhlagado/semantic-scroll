<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="A public experiment in building a publishing system while using it, with essays and specs evolving alongside the code." />
  <link rel="canonical" href="https://jhardy.work/" />
  <meta name="color-scheme" content="light" />
  <meta name="theme-color" content="#ffffff" />
  <title>jhardy.work</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Merriweather:wght@400;700&display=swap" />
  <link rel="icon" type="image/svg+xml" href="/assets/semantic-scroll.svg" />
  <link rel="stylesheet" href="/assets/site.css" />
</head>
<body>
  <div class="page">
    <header class="site-header">
      <a class="site-mark" href="/">
        <img src="/assets/semantic-scroll.svg" alt="Semantic Scroll" width="160" height="160" />
      </a>
      <p class="site-name"><a href="/">jhardy.work</a></p>
      <nav class="site-nav">
        <a href="/content/blog/">Archive</a>
        <a href="/tags/">Tags</a>
      </nav>
    </header>
    <main>
      <h1>The Content Store and the Article Unit</h1>
<p><em>January 10, 2026</em> | Tags: #publishing, #process, #tooling, #structure | Stream: genesis</p>
<p>I treat the content store as the filesystem itself. The repository holds the blog in plain folders, and every entry stays readable with a text editor long after the build scripts change.</p>
<p>Each post lives at `content/blog/YYYY/MM/DD/NN-slug/`. The date and ordinal live in the path, and the slug gives a human handle. That path sets the URL and the order, and it stays fixed as the text evolves.</p>
<pre><code>content/blog/YYYY/MM/DD/NN-slug/
  article.md</code></pre>
<p>Inside the directory I keep a single `article.md` and optional assets for that entry. The directory holds the history, and the file is what I read.</p>
<p>Frontmatter holds status, tags, stream, and summary. The build reads those fields for indexing and queries. The body carries the title, date, tags, and stream in visible text so the Markdown file reads clean on its own.</p>
<p>Queries select which articles appear, and templates stamp them into HTML. The content store feeds both sides, and the structure keeps the mechanics obvious.</p>
<p>I want the archive to be legible a year from now. The path tells me when the work happened, the frontmatter tells me how it was indexed, and the body gives me the full record.</p>
<h1>The Blog Is the Build System</h1>
<p><em>January 10, 2026</em> | Tags: #publishing, #process, #tooling | Stream: genesis</p>
<p>At some point in this project I noticed a shift. I wanted a place to put things while I worked; I ended up with a repository that changes shape every time I write. A new tag, a new stream, a new way of ordering days rewires how everything else fits together.</p>
<p>Each article lands as a directory, a file, and a set of paths that must make sense to the rest of the site. Dates, ordinals, summaries, and queries grow out of publishing, and each decision about finding becomes structure. The writing leaves a footprint the build process has to respect.</p>
<p>That feedback loop is the project. I write because I am thinking, and the system changes because I wrote. Over time, patterns settle into scripts and conventions. A conversation becomes a command. A rough workflow turns into a repeatable one. Automation keeps what survived the thinking and makes it easier to run again.</p>
<p>This is why I keep everything visible and plain. Files, folders, and JSON keep the state legible at a glance, and a change sits in the open where I can see it later. The Git history carries the shape of those decisions like tree rings carry droughts and growth spurts.</p>
<p>What emerges is a site that documents its own construction by existing. Each post advances both the story and the machinery that tells it. Reading backward through the archive shows how the system took on its current form, one day and one choice at a time. That trail is what I am trying to keep.</p>
<h1>Writing Fast Without Writing Sloppily</h1>
<p><em>January 9, 2026</em> | Tags: #writing, #process, #tooling, #automation | Stream: genesis</p>
<p>Writing quickly matters to this project. Without it I'd slow down and publish less. The pace is part of the experiment: ideas form in real time, I'm making decisions under pressure, and the value is in capturing them while they're still alive. That creates tension: speed pulls me toward shortcuts and familiar phrasing that drain the work of voice.</p>
<p>It's easy to slide into that. Certain phrases arrive fully formed. Sentences drift into explanation and leave description behind. Paragraphs climb into commentary about the writing. Language has grooves, and when I'm moving fast, it's tempting to let the wheels fall into them.</p>
<p>Automation helps here, even though it's awkward. I don't believe there's a reliable way to algorithmically judge good writing, and I'm not trying to invent one. What I do think is possible is to detect laziness: repetition, familiar scaffolding, verbal tics when attention drops, passive blur, and phrases that announce ideas before they arrive. These patterns show up quickly.</p>
<p>Part of this project will involve writing local scripts that scan prose and score it for those habits. The scripts are friction: no rewrites, no house style, just a mirror. If a draft trips too many signals, that's my cue to slow down and look again. The tooling doesn't decide what's good.</p>
<p>There's something slightly perverse about using code to guard against formulaic writing, but it fits the larger theme here. Staying awake is the point. Fast writing only helps when it still sounds like someone thinking, without the shape-filling feel of a system. A bit of automation that keeps me honest while I move quickly feels like a fair trade.</p>
<p><em>In case it wasn't obvious, yes of course I will be employing AI to help me write and help me review my text content. Learning how to do this in a timely manner without producing soulless slop is one of the big challenges of this project and one of the design goals is to help me as the writer use the assistance of AI without ever putting it in the driver's seat.</em></p>
<p><em>Steve Jobs once said &quot;the computer is like a bicycle for the mind&quot;. The way I've been thinking about it lately, AI is like an e-bike for mine. Let's hope it doesn't drive me into a ditch!</em></p>
<h1>Why I'm Building This in Public</h1>
<p><em>January 9, 2026</em> | Tags: #publishing, #writing, #process, #ai | Stream: genesis</p>
<p>I'm building this in public because writing things down changes how I think. When ideas stay private they remain vague and provisional. When I write for others, even an imagined reader, the ideas sharpen. Assumptions surface, decisions harden, and gaps show.</p>
<p>This repository is where I'm working things out and where those workings live. I want the notes, the specs, the half-decisions, and the revisions sitting beside the code they shape. I want them as part of the process, present while the code is being shaped.</p>
<p>The writing is one of the tools I'm using to build the system. It affects the choices I make, and it keeps the work honest because it has to be readable to someone besides me.</p>
<p>A large part of the experiment is how AI fits into this. I want AI as a constrained collaborator with clear boundaries about authority, intent, and what is allowed to change. Those constraints preserve the shape of the work while still letting me use speed and advantage when they help.</p>
<p>The blog that will appear here is produced by the project and follows the same rules. As the repository grows, the system that publishes it will grow alongside it. Templates, queries, build scripts, and deployment will show up because the writing needs them.</p>
<p>I am still working out my position, and I am taking my time with it. This is an attempt to think carefully, to design slowly, and to leave a readable trail behind. I want the trail to stand on its own, even if I am the only person who ever reads it end to end.</p>
<h1>Start Here: Building the Tool While Using It</h1>
<p><em>January 9, 2026</em> | Tags: #publishing, #process, #tooling | Stream: genesis</p>
<p>This project exists to test a new model of software development and content production in public. The repository is both the lab and the record, and the system I am building will publish the discoveries that come out of its own construction.</p>
<p>The first content is the documentation process itself. That is why I am writing this as I build: the conversation, the decisions, the constraints, and the contradictions are the raw material. The Q/A process I am working out here is the real work. It becomes the content.</p>
<p>Over time, this back-and-forth will harden into scripts. Today it is a dialogue. Tomorrow it becomes a command. As it stabilizes, the workflow gets more consistent and the content aligns more closely with the system it describes. That is the point of doing it in the open: the system proves itself by publishing its own formation.</p>
<p>I want to minimize imports and treat third-party tools as last resorts. If the problem can be solved cleanly in a small amount of code, I do it myself and I understand it. If that stops being true, I bring in a dependency with intention and say why.</p>
<p>On the publishing side, I am aiming for the most boring convention that still works: a home page index with the newest post at the top, and a dedicated article page for each post with a stable permalink. That is the shape of the site I want to live inside.</p>
<p>This is the beginning of the genesis stream. The next posts will move through the philosophy and the mechanics, but they will stay grounded in the same principle: build the tool while using it, and let the system explain itself in real time.</p>
    </main>
    <footer class="site-footer">
      <p>Published from the same repo that builds this site. <a href="https://github.com/jhlagado/jhardy.work">GitHub</a>.</p>
    </footer>
  </div>
  <script>
    if (location.hostname === 'localhost' || location.hostname === '127.0.0.1') {
      const es = new EventSource('/__reload');
      es.onmessage = () => location.reload();
    }
  </script>
</body>
</html>
